{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CanvasUtils = void 0;\n\nvar ColorUtils_1 = require(\"./ColorUtils\");\n\nvar NumberUtils_1 = require(\"./NumberUtils\");\n\nfunction drawLine(context, begin, end) {\n  context.beginPath();\n  context.moveTo(begin.x, begin.y);\n  context.lineTo(end.x, end.y);\n  context.closePath();\n}\n\nfunction drawTriangle(context, p1, p2, p3) {\n  context.beginPath();\n  context.moveTo(p1.x, p1.y);\n  context.lineTo(p2.x, p2.y);\n  context.lineTo(p3.x, p3.y);\n  context.closePath();\n}\n\nvar CanvasUtils = function () {\n  function CanvasUtils() {\n    _classCallCheck(this, CanvasUtils);\n  }\n\n  _createClass(CanvasUtils, null, [{\n    key: \"paintBase\",\n    value: function paintBase(context, dimension, baseColor) {\n      context.save();\n      context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n      context.fillRect(0, 0, dimension.width, dimension.height);\n      context.restore();\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(context, dimension) {\n      context.clearRect(0, 0, dimension.width, dimension.height);\n    }\n  }, {\n    key: \"drawLinkLine\",\n    value: function drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {\n      var drawn = false;\n\n      if (NumberUtils_1.NumberUtils.getDistance(begin, end) <= maxDistance) {\n        drawLine(context, begin, end);\n        drawn = true;\n      } else if (warp) {\n        var pi1;\n        var pi2;\n        var endNE = {\n          x: end.x - canvasSize.width,\n          y: end.y\n        };\n        var d1 = NumberUtils_1.NumberUtils.getDistances(begin, endNE);\n\n        if (d1.distance <= maxDistance) {\n          var yi = begin.y - d1.dy / d1.dx * begin.x;\n          pi1 = {\n            x: 0,\n            y: yi\n          };\n          pi2 = {\n            x: canvasSize.width,\n            y: yi\n          };\n        } else {\n          var endSW = {\n            x: end.x,\n            y: end.y - canvasSize.height\n          };\n          var d2 = NumberUtils_1.NumberUtils.getDistances(begin, endSW);\n\n          if (d2.distance <= maxDistance) {\n            var _yi = begin.y - d2.dy / d2.dx * begin.x;\n\n            var xi = -_yi / (d2.dy / d2.dx);\n            pi1 = {\n              x: xi,\n              y: 0\n            };\n            pi2 = {\n              x: xi,\n              y: canvasSize.height\n            };\n          } else {\n            var endSE = {\n              x: end.x - canvasSize.width,\n              y: end.y - canvasSize.height\n            };\n            var d3 = NumberUtils_1.NumberUtils.getDistances(begin, endSE);\n\n            if (d3.distance <= maxDistance) {\n              var _yi2 = begin.y - d3.dy / d3.dx * begin.x;\n\n              var _xi = -_yi2 / (d3.dy / d3.dx);\n\n              pi1 = {\n                x: _xi,\n                y: _yi2\n              };\n              pi2 = {\n                x: pi1.x + canvasSize.width,\n                y: pi1.y + canvasSize.height\n              };\n            }\n          }\n        }\n\n        if (pi1 && pi2) {\n          drawLine(context, begin, pi1);\n          drawLine(context, end, pi2);\n          drawn = true;\n        }\n      }\n\n      if (!drawn) {\n        return;\n      }\n\n      context.lineWidth = width;\n\n      if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n      }\n\n      context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n\n      if (shadow.enable) {\n        var shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);\n\n        if (shadowColor) {\n          context.shadowBlur = shadow.blur;\n          context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n        }\n      }\n\n      context.stroke();\n    }\n  }, {\n    key: \"drawLinkTriangle\",\n    value: function drawLinkTriangle(context, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {\n      drawTriangle(context, pos1, pos2, pos3);\n\n      if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n      }\n\n      context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);\n      context.fill();\n    }\n  }, {\n    key: \"drawConnectLine\",\n    value: function drawConnectLine(context, width, lineStyle, begin, end) {\n      context.save();\n      drawLine(context, begin, end);\n      context.lineWidth = width;\n      context.strokeStyle = lineStyle;\n      context.stroke();\n      context.restore();\n    }\n  }, {\n    key: \"gradient\",\n    value: function gradient(context, p1, p2, opacity) {\n      var gradStop = Math.floor(p2.getRadius() / p1.getRadius());\n      var color1 = p1.getFillColor();\n      var color2 = p2.getFillColor();\n\n      if (!color1 || !color2) {\n        return;\n      }\n\n      var sourcePos = p1.getPosition();\n      var destPos = p2.getPosition();\n      var midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.getRadius(), p2.getRadius());\n      var grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n      grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));\n      grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));\n      grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));\n      return grad;\n    }\n  }, {\n    key: \"drawGrabLine\",\n    value: function drawGrabLine(context, width, begin, end, colorLine, opacity) {\n      context.save();\n      drawLine(context, begin, end);\n      context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n      context.lineWidth = width;\n      context.stroke();\n      context.restore();\n    }\n  }, {\n    key: \"drawLight\",\n    value: function drawLight(container, context, mousePos) {\n      var lightOptions = container.options.interactivity.modes.light.area;\n      context.beginPath();\n      context.arc(mousePos.x, mousePos.y, lightOptions.radius, 0, 2 * Math.PI);\n      var gradientAmbientLight = context.createRadialGradient(mousePos.x, mousePos.y, 0, mousePos.x, mousePos.y, lightOptions.radius);\n      var gradient = lightOptions.gradient;\n      var gradientRgb = {\n        start: ColorUtils_1.ColorUtils.colorToRgb(gradient.start),\n        stop: ColorUtils_1.ColorUtils.colorToRgb(gradient.stop)\n      };\n\n      if (!gradientRgb.start || !gradientRgb.stop) {\n        return;\n      }\n\n      gradientAmbientLight.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.start));\n      gradientAmbientLight.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.stop));\n      context.fillStyle = gradientAmbientLight;\n      context.fill();\n    }\n  }, {\n    key: \"drawParticleShadow\",\n    value: function drawParticleShadow(container, context, particle, mousePos) {\n      var pos = particle.getPosition();\n      var shadowOptions = container.options.interactivity.modes.light.shadow;\n      context.save();\n      var radius = particle.getRadius();\n      var sides = particle.sides;\n      var full = Math.PI * 2 / sides;\n      var angle = -particle.rotate.value + Math.PI / 4;\n      var factor = 1;\n      var dots = [];\n\n      for (var i = 0; i < sides; i++) {\n        dots.push({\n          x: pos.x + radius * Math.sin(angle + full * i) * factor,\n          y: pos.y + radius * Math.cos(angle + full * i) * factor\n        });\n      }\n\n      var points = [];\n      var shadowLength = shadowOptions.length;\n\n      for (var _i = 0, _dots = dots; _i < _dots.length; _i++) {\n        var dot = _dots[_i];\n        var dotAngle = Math.atan2(mousePos.y - dot.y, mousePos.x - dot.x);\n        var endX = dot.x + shadowLength * Math.sin(-dotAngle - Math.PI / 2);\n        var endY = dot.y + shadowLength * Math.cos(-dotAngle - Math.PI / 2);\n        points.push({\n          endX: endX,\n          endY: endY,\n          startX: dot.x,\n          startY: dot.y\n        });\n      }\n\n      var shadowRgb = ColorUtils_1.ColorUtils.colorToRgb(shadowOptions.color);\n\n      if (!shadowRgb) {\n        return;\n      }\n\n      var shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowRgb);\n\n      for (var _i2 = points.length - 1; _i2 >= 0; _i2--) {\n        var n = _i2 == points.length - 1 ? 0 : _i2 + 1;\n        context.beginPath();\n        context.moveTo(points[_i2].startX, points[_i2].startY);\n        context.lineTo(points[n].startX, points[n].startY);\n        context.lineTo(points[n].endX, points[n].endY);\n        context.lineTo(points[_i2].endX, points[_i2].endY);\n        context.fillStyle = shadowColor;\n        context.fill();\n      }\n\n      context.restore();\n    }\n  }, {\n    key: \"drawParticle\",\n    value: function drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow) {\n      var pos = particle.getPosition();\n      context.save();\n      context.translate(pos.x, pos.y);\n      context.beginPath();\n      var angle = particle.rotate.value + (particle.particlesOptions.rotate.path ? particle.pathAngle : 0);\n\n      if (angle !== 0) {\n        context.rotate(angle);\n      }\n\n      if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n      }\n\n      var shadowColor = particle.shadowColor;\n\n      if (shadow.enable && shadowColor) {\n        context.shadowBlur = shadow.blur;\n        context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n        context.shadowOffsetX = shadow.offset.x;\n        context.shadowOffsetY = shadow.offset.y;\n      }\n\n      if (fillColorValue) {\n        context.fillStyle = fillColorValue;\n      }\n\n      var stroke = particle.stroke;\n      context.lineWidth = particle.strokeWidth;\n\n      if (strokeColorValue) {\n        context.strokeStyle = strokeColorValue;\n      }\n\n      CanvasUtils.drawShape(container, context, particle, radius, opacity, delta);\n\n      if (stroke.width > 0) {\n        context.stroke();\n      }\n\n      if (particle.close) {\n        context.closePath();\n      }\n\n      if (particle.fill) {\n        context.fill();\n      }\n\n      context.restore();\n      context.save();\n      context.translate(pos.x, pos.y);\n\n      if (angle !== 0) {\n        context.rotate(angle);\n      }\n\n      if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n      }\n\n      CanvasUtils.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n      context.restore();\n    }\n  }, {\n    key: \"drawShape\",\n    value: function drawShape(container, context, particle, radius, opacity, delta) {\n      if (!particle.shape) {\n        return;\n      }\n\n      var drawer = container.drawers.get(particle.shape);\n\n      if (!drawer) {\n        return;\n      }\n\n      drawer.draw(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n    }\n  }, {\n    key: \"drawShapeAfterEffect\",\n    value: function drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n      if (!particle.shape) {\n        return;\n      }\n\n      var drawer = container.drawers.get(particle.shape);\n\n      if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n        return;\n      }\n\n      drawer.afterEffect(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n    }\n  }, {\n    key: \"drawPlugin\",\n    value: function drawPlugin(context, plugin, delta) {\n      if (plugin.draw !== undefined) {\n        context.save();\n        plugin.draw(context, delta);\n        context.restore();\n      }\n    }\n  }]);\n\n  return CanvasUtils;\n}();\n\nexports.CanvasUtils = CanvasUtils;","map":{"version":3,"sources":["/Users/matteo/Projects/GitHub Projects/tsparticles/tsparticles-master/demo/react-native/node_modules/react-native-tsparticles/node_modules/tsparticles/dist/Utils/CanvasUtils.js"],"names":["Object","defineProperty","exports","value","CanvasUtils","ColorUtils_1","require","NumberUtils_1","drawLine","context","begin","end","beginPath","moveTo","x","y","lineTo","closePath","drawTriangle","p1","p2","p3","dimension","baseColor","save","fillStyle","fillRect","width","height","restore","clearRect","maxDistance","canvasSize","warp","backgroundMask","composite","colorLine","opacity","shadow","drawn","NumberUtils","getDistance","pi1","pi2","endNE","d1","getDistances","distance","yi","dy","dx","endSW","d2","xi","endSE","d3","lineWidth","globalCompositeOperation","strokeStyle","ColorUtils","getStyleFromRgb","enable","shadowColor","colorToRgb","color","shadowBlur","blur","stroke","pos1","pos2","pos3","colorTriangle","opacityTriangle","fill","lineStyle","gradStop","Math","floor","getRadius","color1","getFillColor","color2","sourcePos","getPosition","destPos","midRgb","mix","grad","createLinearGradient","addColorStop","getStyleFromHsl","container","mousePos","lightOptions","options","interactivity","modes","light","area","arc","radius","PI","gradientAmbientLight","createRadialGradient","gradient","gradientRgb","start","stop","particle","pos","shadowOptions","sides","full","angle","rotate","factor","dots","i","push","sin","cos","points","shadowLength","length","dot","dotAngle","atan2","endX","endY","startX","startY","shadowRgb","n","delta","fillColorValue","strokeColorValue","translate","particlesOptions","path","pathAngle","shadowOffsetX","offset","shadowOffsetY","strokeWidth","drawShape","close","drawShapeAfterEffect","shape","drawer","drawers","get","draw","retina","pixelRatio","afterEffect","plugin","undefined"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CanvasUtils = void 0;\nconst ColorUtils_1 = require(\"./ColorUtils\");\nconst NumberUtils_1 = require(\"./NumberUtils\");\nfunction drawLine(context, begin, end) {\n    context.beginPath();\n    context.moveTo(begin.x, begin.y);\n    context.lineTo(end.x, end.y);\n    context.closePath();\n}\nfunction drawTriangle(context, p1, p2, p3) {\n    context.beginPath();\n    context.moveTo(p1.x, p1.y);\n    context.lineTo(p2.x, p2.y);\n    context.lineTo(p3.x, p3.y);\n    context.closePath();\n}\nclass CanvasUtils {\n    static paintBase(context, dimension, baseColor) {\n        context.save();\n        context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n        context.fillRect(0, 0, dimension.width, dimension.height);\n        context.restore();\n    }\n    static clear(context, dimension) {\n        context.clearRect(0, 0, dimension.width, dimension.height);\n    }\n    static drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {\n        let drawn = false;\n        if (NumberUtils_1.NumberUtils.getDistance(begin, end) <= maxDistance) {\n            drawLine(context, begin, end);\n            drawn = true;\n        }\n        else if (warp) {\n            let pi1;\n            let pi2;\n            const endNE = {\n                x: end.x - canvasSize.width,\n                y: end.y,\n            };\n            const d1 = NumberUtils_1.NumberUtils.getDistances(begin, endNE);\n            if (d1.distance <= maxDistance) {\n                const yi = begin.y - (d1.dy / d1.dx) * begin.x;\n                pi1 = { x: 0, y: yi };\n                pi2 = { x: canvasSize.width, y: yi };\n            }\n            else {\n                const endSW = {\n                    x: end.x,\n                    y: end.y - canvasSize.height,\n                };\n                const d2 = NumberUtils_1.NumberUtils.getDistances(begin, endSW);\n                if (d2.distance <= maxDistance) {\n                    const yi = begin.y - (d2.dy / d2.dx) * begin.x;\n                    const xi = -yi / (d2.dy / d2.dx);\n                    pi1 = { x: xi, y: 0 };\n                    pi2 = { x: xi, y: canvasSize.height };\n                }\n                else {\n                    const endSE = {\n                        x: end.x - canvasSize.width,\n                        y: end.y - canvasSize.height,\n                    };\n                    const d3 = NumberUtils_1.NumberUtils.getDistances(begin, endSE);\n                    if (d3.distance <= maxDistance) {\n                        const yi = begin.y - (d3.dy / d3.dx) * begin.x;\n                        const xi = -yi / (d3.dy / d3.dx);\n                        pi1 = { x: xi, y: yi };\n                        pi2 = { x: pi1.x + canvasSize.width, y: pi1.y + canvasSize.height };\n                    }\n                }\n            }\n            if (pi1 && pi2) {\n                drawLine(context, begin, pi1);\n                drawLine(context, end, pi2);\n                drawn = true;\n            }\n        }\n        if (!drawn) {\n            return;\n        }\n        context.lineWidth = width;\n        if (backgroundMask) {\n            context.globalCompositeOperation = composite;\n        }\n        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n        if (shadow.enable) {\n            const shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);\n            if (shadowColor) {\n                context.shadowBlur = shadow.blur;\n                context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n            }\n        }\n        context.stroke();\n    }\n    static drawLinkTriangle(context, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {\n        drawTriangle(context, pos1, pos2, pos3);\n        if (backgroundMask) {\n            context.globalCompositeOperation = composite;\n        }\n        context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);\n        context.fill();\n    }\n    static drawConnectLine(context, width, lineStyle, begin, end) {\n        context.save();\n        drawLine(context, begin, end);\n        context.lineWidth = width;\n        context.strokeStyle = lineStyle;\n        context.stroke();\n        context.restore();\n    }\n    static gradient(context, p1, p2, opacity) {\n        const gradStop = Math.floor(p2.getRadius() / p1.getRadius());\n        const color1 = p1.getFillColor();\n        const color2 = p2.getFillColor();\n        if (!color1 || !color2) {\n            return;\n        }\n        const sourcePos = p1.getPosition();\n        const destPos = p2.getPosition();\n        const midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.getRadius(), p2.getRadius());\n        const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n        grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));\n        grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));\n        grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));\n        return grad;\n    }\n    static drawGrabLine(context, width, begin, end, colorLine, opacity) {\n        context.save();\n        drawLine(context, begin, end);\n        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n        context.lineWidth = width;\n        context.stroke();\n        context.restore();\n    }\n    static drawLight(container, context, mousePos) {\n        const lightOptions = container.options.interactivity.modes.light.area;\n        context.beginPath();\n        context.arc(mousePos.x, mousePos.y, lightOptions.radius, 0, 2 * Math.PI);\n        const gradientAmbientLight = context.createRadialGradient(mousePos.x, mousePos.y, 0, mousePos.x, mousePos.y, lightOptions.radius);\n        const gradient = lightOptions.gradient;\n        const gradientRgb = {\n            start: ColorUtils_1.ColorUtils.colorToRgb(gradient.start),\n            stop: ColorUtils_1.ColorUtils.colorToRgb(gradient.stop),\n        };\n        if (!gradientRgb.start || !gradientRgb.stop) {\n            return;\n        }\n        gradientAmbientLight.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.start));\n        gradientAmbientLight.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.stop));\n        context.fillStyle = gradientAmbientLight;\n        context.fill();\n    }\n    static drawParticleShadow(container, context, particle, mousePos) {\n        const pos = particle.getPosition();\n        const shadowOptions = container.options.interactivity.modes.light.shadow;\n        context.save();\n        const radius = particle.getRadius();\n        const sides = particle.sides;\n        const full = (Math.PI * 2) / sides;\n        const angle = -particle.rotate.value + Math.PI / 4;\n        const factor = 1;\n        const dots = [];\n        for (let i = 0; i < sides; i++) {\n            dots.push({\n                x: pos.x + radius * Math.sin(angle + full * i) * factor,\n                y: pos.y + radius * Math.cos(angle + full * i) * factor,\n            });\n        }\n        const points = [];\n        const shadowLength = shadowOptions.length;\n        for (const dot of dots) {\n            const dotAngle = Math.atan2(mousePos.y - dot.y, mousePos.x - dot.x);\n            const endX = dot.x + shadowLength * Math.sin(-dotAngle - Math.PI / 2);\n            const endY = dot.y + shadowLength * Math.cos(-dotAngle - Math.PI / 2);\n            points.push({\n                endX: endX,\n                endY: endY,\n                startX: dot.x,\n                startY: dot.y,\n            });\n        }\n        const shadowRgb = ColorUtils_1.ColorUtils.colorToRgb(shadowOptions.color);\n        if (!shadowRgb) {\n            return;\n        }\n        const shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowRgb);\n        for (let i = points.length - 1; i >= 0; i--) {\n            const n = i == points.length - 1 ? 0 : i + 1;\n            context.beginPath();\n            context.moveTo(points[i].startX, points[i].startY);\n            context.lineTo(points[n].startX, points[n].startY);\n            context.lineTo(points[n].endX, points[n].endY);\n            context.lineTo(points[i].endX, points[i].endY);\n            context.fillStyle = shadowColor;\n            context.fill();\n        }\n        context.restore();\n    }\n    static drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow) {\n        const pos = particle.getPosition();\n        context.save();\n        context.translate(pos.x, pos.y);\n        context.beginPath();\n        const angle = particle.rotate.value + (particle.particlesOptions.rotate.path ? particle.pathAngle : 0);\n        if (angle !== 0) {\n            context.rotate(angle);\n        }\n        if (backgroundMask) {\n            context.globalCompositeOperation = composite;\n        }\n        const shadowColor = particle.shadowColor;\n        if (shadow.enable && shadowColor) {\n            context.shadowBlur = shadow.blur;\n            context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n            context.shadowOffsetX = shadow.offset.x;\n            context.shadowOffsetY = shadow.offset.y;\n        }\n        if (fillColorValue) {\n            context.fillStyle = fillColorValue;\n        }\n        const stroke = particle.stroke;\n        context.lineWidth = particle.strokeWidth;\n        if (strokeColorValue) {\n            context.strokeStyle = strokeColorValue;\n        }\n        CanvasUtils.drawShape(container, context, particle, radius, opacity, delta);\n        if (stroke.width > 0) {\n            context.stroke();\n        }\n        if (particle.close) {\n            context.closePath();\n        }\n        if (particle.fill) {\n            context.fill();\n        }\n        context.restore();\n        context.save();\n        context.translate(pos.x, pos.y);\n        if (angle !== 0) {\n            context.rotate(angle);\n        }\n        if (backgroundMask) {\n            context.globalCompositeOperation = composite;\n        }\n        CanvasUtils.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n        context.restore();\n    }\n    static drawShape(container, context, particle, radius, opacity, delta) {\n        if (!particle.shape) {\n            return;\n        }\n        const drawer = container.drawers.get(particle.shape);\n        if (!drawer) {\n            return;\n        }\n        drawer.draw(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n    }\n    static drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n        if (!particle.shape) {\n            return;\n        }\n        const drawer = container.drawers.get(particle.shape);\n        if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n            return;\n        }\n        drawer.afterEffect(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n    }\n    static drawPlugin(context, plugin, delta) {\n        if (plugin.draw !== undefined) {\n            context.save();\n            plugin.draw(context, delta);\n            context.restore();\n        }\n    }\n}\nexports.CanvasUtils = CanvasUtils;\n"]},"metadata":{},"sourceType":"script"}